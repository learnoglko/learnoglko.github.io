# 큐브맵

우리는 2D 텍스처를 꽤 오랫동안 사용해 왔지만, 아직 살펴보지 않은 텍스처 유형이 더 있습니다. 이 장에서는 여러 텍스처를 하나로 매핑한 조합인 **큐브맵**{:.g}이라는 텍스처 유형에 대해 알아보겠습니다.

큐브맵은 각각 정육면체의 한 면을 이루는 6개의 개별 2D 텍스처를 포함하는 텍스처입니다. 즉, 텍스처가 적용된 정육면체인 셈이죠. 이런 정육면체가 왜 필요한지 궁금하실 수도 있습니다. 6개의 개별 텍스처를 그냥 사용하는 대신 왜 하나의 엔티티로 결합하는 걸까요? 큐브맵은 방향 벡터를 사용하여 인덱싱/샘플링할 수 있다는 유용한 속성을 가지고 있습니다. 중심을 방향 벡터의 원점으로 하는 1x1x1 크기의 정육면체가 있다고 상상해 보세요. 주황색 ​​방향 벡터를 사용하여 큐브맵에서 텍스처 값을 샘플링하는 것은 다음과 같습니다.

![](../static/cubemaps_sampling.png)

!!! tip ""
    방향 벡터의 크기는 중요하지 않습니다. 방향만 제공되면 OpenGL은 해당 방향이 만나는 텍셀을 (결국) 검색하여 올바르게 샘플링된 텍스처 값을 반환합니다.

큐브맵을 적용한 정육면체 모양이 있다고 가정해 봅시다. 이 방향 벡터는 정육면체의 (보간된) 로컬 정점 위치와 유사합니다. 이처럼 정육면체가 원점을 중심으로 위치하는 한, 정육면체의 실제 위치 벡터를 사용하여 큐브맵을 샘플링할 수 있습니다. 따라서 큐브맵을 샘플링할 때 정육면체의 모든 정점 위치를 텍스처 좌표로 간주합니다. 결과적으로 **큐브맵의 각 면**{:.g}의 텍스처에 접근하는 텍스처 좌표를 얻게 됩니다.

!!! note ""
    샘플링이란, 텍스처에서 색상을 가져오는 것을 뜻합니다. 그러니까, 큐브맵을 사용하면 벡터를 사용해서 텍스처를 샘플링 할 수 있습니다.

## 큐브맵 생성

큐브맵은 다른 텍스처와 마찬가지로 텍스처이므로, 큐브맵을 생성하려면 텍스처를 생성하고 추가적인 텍스처 작업을 수행하기 전에 적절한 텍스처 대상에 바인딩해야 합니다. 이번에는 `GL_TEXTURE_CUBE_MAP`에 바인딩합니다.

```c++
unsigned int textureID;
glGenTextures(1, &textureID);
glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);
```

큐브맵은 각 면에 하나씩, 총 6개의 텍스처를 포함하므로 이전 장에서와 마찬가지로 매개변수를 설정하여 glTexImage2D 함수를 6번 호출해야 합니다. 하지만 이번에는 텍스처 대상 매개변수를 큐브맵의 특정 면과 일치하도록 설정해야 합니다. 즉, 큐브맵의 어느 면에 대한 텍스처를 생성할지 OpenGL에 알려주는 것입니다. 따라서 큐브맵의 각 면에 대해 glTexImage2D 함수를 한 번씩 호출해야 합니다.

큐브맵에는 6개의 면이 있으므로 OpenGL은 큐브맵의 각 면을 대상으로 지정할 수 있는 6개의 특수 텍스처 타겟을 제공합니다.

| 텍스처 타겟| 방향 |
| :--- | :--- |
| GL_TEXTURE_CUBE_MAP_POSITIVE_X | 오른쪽 |
| GL_TEXTURE_CUBE_MAP_NEGATIVE_X | 왼쪽 |
| GL_TEXTURE_CUBE_MAP_POSITIVE_Y | 위 |
| GL_TEXTURE_CUBE_MAP_NEGATIVE_Y | 아래 |
| GL_TEXTURE_CUBE_MAP_POSITIVE_Z | 뒤 |
| GL_TEXTURE_CUBE_MAP_NEGATIVE_Z | 앞 |

OpenGL의 많은 열거형과 마찬가지로, 내부적으로 사용되는 정수 값은 선형적으로 증가합니다. 따라서 텍스처 위치 배열이나 벡터가 있는 경우, `GL_TEXTURE_CUBE_MAP_POSITIVE_X`부터 시작하여 각 반복마다 열거형 값을 1씩 증가시키면서 모든 텍스처 대상을 효과적으로 순회할 수 있습니다.

```c++
int width, height, nrChannels;
unsigned char *data;  
for(unsigned int i = 0; i < textures_faces.size(); i++)
{
    data = stbi_load(textures_faces[i].c_str(), &width, &height, &nrChannels, 0);
    glTexImage2D(
        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 
        0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data
    );
}
```

여기에는 테이블에 제시된 순서대로 큐브맵에 필요한 모든 텍스처의 위치를 ​​포함하는 textures_faces라는 벡터가 있습니다. 이를 통해 현재 바인딩된 큐브맵의 각 면에 대한 텍스처가 생성됩니다.

큐브맵은 다른 텍스처와 마찬가지로 텍스처이므로 래핑 및 필터링 방법도 지정해야 합니다.


```c++
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);  
```

`GL_TEXTURE_WRAP_R`에 겁먹지 마세요. 이것은 단순히 텍스처의 R 좌표(위치의 z축과 같은 세 번째 차원)에 대한 래핑 방식을 설정하는 것입니다. 텍스처 좌표가 두 면 사이에 정확히 위치하더라도 하드웨어적인 제약으로 인해 정확한 면에 닿지 않을 수 있기 때문에, `GL_CLAMP_TO_EDGE`를 사용하면 OpenGL은 면 사이를 샘플링할 때마다 항상 경계 값을 반환합니다.

큐브맵을 사용할 객체를 그리기 전에 해당 텍스처 유닛을 활성화하고 렌더링 전에 큐브맵을 바인딩합니다. 일반적인 2D 텍스처와 크게 다르지 않습니다.

프래그먼트 셰이더 내부에서도 텍스처 함수를 사용하여 샘플링하는 `samplerCube` 타입의 다른 샘플러를 사용해야 하는데, 이때 vec2 방향 벡터 대신 vec3 방향 벡터를 사용합니다. 큐브맵을 사용하는 프래그먼트 셰이더의 예는 다음과 같습니다.

```c++
in vec3 textureDir; // 3D 텍스처 좌표를 나타내는 방향 벡터
uniform samplerCube cubemap; // 큐브맵 텍스처 샘플러

void main()
{             
    FragColor = texture(cubemap, textureDir);
}  
```

그것도 물론 좋긴 하지만, 굳이 그럴 필요가 있을까요? 사실 큐브맵을 사용하면 훨씬 쉽게 구현할 수 있는 흥미로운 기술들이 꽤 많습니다. 그중 하나가 **스카이박스**{:.g}를 만드는 기술입니다.

## 스카이박스

스카이박스는 전체 장면을 감싸는 (커다란) 정육면체로, 주변 환경의 이미지 6개를 포함하여 플레이어에게 실제보다 훨씬 더 넓어 보이는 착각을 불러일으킵니다. 비디오 게임에서 사용되는 스카이박스의 예로는 산, 구름, 별이 빛나는 밤하늘 이미지가 있습니다. 별이 빛나는 밤하늘 이미지를 사용한 스카이박스의 예는 엘더스크롤 3의 다음 스크린샷에서 확인할 수 있습니다.

![](../static/cubemaps_morrowind.jpg)

아마 이미 짐작하셨겠지만, 이런 스카이박스는 큐브맵에 완벽하게 어울립니다. 큐브맵은 6개의 면을 가지고 있고, 각 면마다 텍스처를 입혀야 하기 때문입니다. 이전 이미지에서는 여러 장의 밤하늘 이미지를 사용하여 플레이어가 실제로는 아주 작은 상자 안에 있지만 마치 광활한 우주에 있는 듯한 착각을 불러일으켰습니다.

일반적으로 온라인에는 그러한 스카이박스를 찾을 수 있는 자료가 충분히 있습니다. 이러한 스카이박스 이미지는 대개 다음과 같은 패턴을 가지고 있습니다.

![](../static/cubemaps_skybox.png)

이 6개의 면을 접어서 정육면체를 만들면 넓은 풍경을 시뮬레이션하는 완전히 텍스처링된 정육면체를 얻을 수 있습니다. 일부 리소스는 스카이박스를 이와 같은 형식으로 제공하는데, 이 경우 6개의 면 이미지를 수동으로 추출해야 하지만, 대부분의 경우 6개의 단일 텍스처 이미지로 제공됩니다.

이 특정 (고품질) 스카이박스는 우리가 장면에 사용할 것이며, [여기](../static/skybox.zip)에서 다운로드할 수 있습니다.