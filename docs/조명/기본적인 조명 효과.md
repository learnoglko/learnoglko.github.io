# 기본적인 조명 효과

실제 세계의 조명은 매우 복잡하며 수많은 요소에 따라 달라지기 때문에, 제한된 처리 능력으로 모든 요소를 ​​계산하는 것은 불가능합니다. 따라서 OpenGL의 조명은 현실을 근사화하여 처리하기 훨씬 쉽고 상대적으로 유사한 모습을 보이는 단순화된 모델을 사용합니다. 이러한 조명 모델은 우리가 이해하는 빛의 물리적 원리에 기반합니다. 그중 하나가 **퐁(Phong) 조명 모델**{:.g}입니다. 퐁 조명 모델의 주요 구성 요소는 주변광, 확산광, 반사광의 세 가지입니다. 아래에서 이러한 조명 요소들이 각각 그리고 모두 합쳐졌을 때 어떤 모습인지 확인할 수 있습니다.

![](../static/basic_lighting_phong.png)

 - **주변(Ambient)**{:.g} 조명: 완전히 어두울 때에도 세상 어딘가에는 보통 빛(달빛, 멀리 있는 불빛 등)이 존재하기 때문에 물체가 완전히 어두운 경우는 거의 없습니다. 이를 시뮬레이션하기 위해 물체에 항상 색을 부여하는 주변 조명 상수를 사용합니다.
 - **확산(Diffuse)**{:.g} 조명: 광원이 물체에 미치는 방향성 영향을 시뮬레이션합니다. 이는 조명 모델에서 시각적으로 가장 중요한 요소입니다. 물체의 어느 부분이 광원을 향할수록 더 밝아집니다.
 - **반사(Specular)**{:.g} 조명: 광택이 있는 물체에 나타나는 빛의 밝은 부분을 시뮬레이션합니다. 반사광은 물체의 색상보다는 빛의 색상에 더 영향을 받습니다.

시각적으로 흥미로운 장면을 만들기 위해서는 최소한 이 세 가지 조명 요소를 시뮬레이션해야 합니다. 가장 간단한 것부터 시작해 보겠습니다. 바로 주변 조명입니다.

## 주변 조명(주변광)

빛은 보통 하나의 광원에서 나오는 것이 아니라, 우리 주변 곳곳에 흩어져 있는 수많은 광원에서 나옵니다. 심지어 눈에 바로 보이지 않는 광원까지도 빛이 도달할 수 있습니다. 빛의 특성 중 하나는 여러 방향으로 산란되고 반사되어 직접 보이지 않는 곳까지 도달할 수 있다는 것입니다. 따라서 빛은 다른 표면에 반사되어 물체의 조명에 간접적인 영향을 미칠 수 있습니다. 이러한 점을 고려한 알고리즘을 **전역 조명**{:.g} 알고리즘이라고 하지만, 이러한 알고리즘은 복잡하고 계산 비용이 많이 듭니다.

복잡하고 비용이 많이 드는 알고리즘을 선호하지 않기 때문에, 먼저 매우 단순한 전역 조명 모델인 **주변광**{:.g}을 사용하겠습니다. 이전 섹션에서 보셨듯이, 객체 조각의 최종 색상에 작은 상수(밝은) 색상을 더하여 직접적인 광원이 없더라도 항상 산란광이 있는 것처럼 보이게 합니다.

장면에 주변 조명을 추가하는 것은 매우 쉽습니다. 광원의 색상에 작은 상수 주변 조명 계수를 곱하고, 이 값을 오브젝트의 색상에 곱한 다음, 이 값을 큐브 오브젝트 셰이더에서 프래그먼트 색상으로 사용하면 됩니다.

```c++
void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}  
```

이제 프로그램을 실행하면 첫 번째 단계의 조명이 객체에 성공적으로 적용된 것을 확인할 수 있습니다. 객체는 상당히 어둡지만 주변 조명이 적용되어 완전히 어둡지는 않습니다(라이트 큐브는 다른 셰이더를 사용하기 때문에 영향을 받지 않습니다). 결과는 대략 다음과 같을 것입니다.

![](../static/ambient_lighting.png)

## 확산 조명(확산광)

주변 조명만으로는 그다지 흥미로운 결과를 얻기 어렵지만, 확산 조명을 사용하면 사물에 상당한 시각적 효과를 줄 수 있습니다. 확산 조명은 사물의 각 부분이 광원에서 나오는 빛줄기에 가까울수록 더 밝게 빛나도록 합니다. 확산 조명을 더 잘 이해하려면 다음 이미지를 참고하세요.

![](../static/diffuse_light.png)

왼쪽에는 광원에서 나오는 빛이 물체의 한 조각을 향해 비추고 있습니다. 우리는 빛이 조각에 닿는 각도를 측정해야 합니다. 빛이 물체 표면에 수직일 때 빛은 가장 큰 영향을 미칩니다. 빛과 조각 사이의 각도를 측정하기 위해 우리는 법선 벡터라는 것을 사용합니다. **법선 벡터(normal vector)**{:.g}는 조각 표면에 수직인 벡터입니다(여기서는 노란색 화살표로 표시됨). 이에 대해서는 나중에 자세히 설명하겠습니다. 두 벡터 사이의 각도는 내적을 이용하여 쉽게 계산할 수 있습니다.

[변형 단원](../시작하기/변형.md)에서 배웠듯이, 두 단위 벡터 사이의 각도가 작을수록 내적은 1에 가까워집니다. 두 벡터 사이의 각도가 90도일 때 내적은 0이 됩니다. $\theta$에도 동일하게 적용됩니다. $\theta$가 커질수록 빛이 조각의 색상에 미치는 영향은 줄어듭니다.

!!! tip ""
    두 벡터 사이의 각도의 코사인 값만 얻으려면 단위 벡터(길이가 1인 벡터)를 사용해야 하므로 모든 벡터를 정규화해야 합니다. 그렇지 않으면 내적 계산 시 코사인 값 외에도 다른 값이 반환됩니다([변형](../시작하기/변형.md) 참조).

결과적으로 얻어지는 내적은 스칼라 값을 반환하며, 이 값을 사용하여 빛이 조각의 색상에 미치는 영향을 계산할 수 있습니다. 따라서 빛을 향한 조각의 방향에 따라 조명이 다르게 나타나는 것을 확인할 수 있습니다.

그렇다면 확산광을 계산하려면 무엇이 필요할까요?

- 법선 벡터: 꼭짓점의 표면에 수직인 벡터.
- 방향 광선: 광원의 위치와 파편의 위치 차이 벡터인 방향 벡터입니다. 이 광선을 계산하려면 광원의 위치 벡터와 파편의 위치 벡터가 필요합니다.

### 법선 벡터

법선 벡터는 꼭짓점의 표면에 수직인 (단위) 벡터입니다. 꼭짓점 자체는 표면이 없기 때문에 (공간상의 한 점일 뿐입니다), 주변 꼭짓점들을 이용하여 꼭짓점의 표면을 파악하고 법선 벡터를 구합니다. 외적을 이용하면 큐브의 모든 꼭짓점에 대한 법선 벡터를 계산할 수 있지만, 3D 큐브는 복잡한 도형이 아니므로 단순히 꼭짓점 데이터에 수동으로 추가하는 것이 더 간단합니다. 업데이트된 꼭짓점 데이터 배열은 [여기](../cube_code3.md)에서 확인할 수 있습니다. 법선 벡터가 각 평면의 표면에 수직인 벡터임을 시각적으로 이해해 보세요 (큐브는 6개의 평면으로 이루어져 있습니다).

정점 배열에 추가 데이터를 넣었으므로 큐브의 정점 셰이더를 업데이트해야 합니다.

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
...
```

이제 각 정점에 법선 벡터를 추가하고 정점 셰이더를 업데이트했으므로 정점 속성 포인터도 업데이트해야 합니다. 광원 큐브는 정점 데이터에 동일한 정점 배열을 사용하지만, 조명 셰이더는 새로 추가된 법선 벡터를 사용하지 않습니다. 조명 셰이더나 속성 설정을 업데이트할 필요는 없지만, 최소한 정점 속성 포인터를 수정하여 새 정점 배열의 크기를 반영해야 합니다.

```c++
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```
