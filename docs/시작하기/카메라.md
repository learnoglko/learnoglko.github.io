원본: [Camera](https://learnopengl.com/Getting-started/Camera)

# 카메라

이전 장에서는 뷰 행렬과 뷰 행렬을 사용하여 장면을 이동하는 방법에 대해 이야기했습니다. OpenGL 자체는 카메라 개념을 지원하지 않지만, 장면의 모든 객체를 반대 방향으로 움직여 마치 움직이는 것처럼 보이게 할 수 있습니다.

이 장에서는 OpenGL에서 카메라를 설정하는 방법을 살펴보겠습니다. 3D 장면에서 자유롭게 이동할 수 있는 플라이 스타일 카메라에 대해 논의하고, 키보드 및 마우스 입력에 대해서도 살펴본 후, 사용자 정의 카메라 클래스를 만드는 것으로 마무리하겠습니다.

## 카메라 또는 뷰 공간

카메라 또는 뷰 공간에 대해 이야기할 때, 우리는 장면의 원점인 카메라의 시점에서 바라본 모든 정점 좌표를 의미합니다. 뷰 행렬은 모든 월드 좌표를 카메라의 위치와 방향을 기준으로 하는 뷰 좌표로 변환합니다. 카메라를 정의하려면 월드 공간에서의 위치, 카메라가 바라보는 방향, 오른쪽을 가리키는 벡터, 그리고 위쪽을 가리키는 벡터가 필요합니다. 주의 깊게 읽는 사람은 우리가 실제로 카메라의 위치를 ​​원점으로 하는 세 개의 수직 단위 축으로 이루어진 좌표계를 만들 것이라는 점을 알아차릴 수 있을 것입니다.

![](../static/camera_axes.png)

### 1. 카메라 위치

카메라 위치를 구하는 것은 쉽습니다. 카메라 위치는 카메라의 위치를 ​​가리키는 월드 공간상의 벡터입니다. 이전 장에서 설정했던 것과 동일한 위치에 카메라를 설정합니다.

```c++
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);  
```

!!! tip ""
    양의 z축은 화면을 통과하여 사용자 쪽으로 향한다는 점을 잊지 마세요. 따라서 카메라를 뒤로 이동시키려면 양의 z축을 따라 이동해야 합니다.

### 2. 카메라 방향

다음으로 필요한 벡터는 카메라의 방향, 즉 카메라가 가리키는 방향입니다. 지금은 카메라가 장면의 원점인 (0,0,0)을 가리킨다고 가정합니다. 두 벡터를 빼면 두 벡터의 차이가 되는 벡터가 나온다는 것을 기억하세요. 따라서 장면의 원점 벡터에서 카메라 위치 벡터를 빼면 우리가 원하는 방향 벡터를 얻을 수 있습니다. 뷰 행렬의 좌표계에서 z축은 양수여야 하고, OpenGL에서는 관례적으로 카메라가 음의 z축을 가리키므로 방향 벡터의 부호를 반대로 해야 합니다. 따라서 빼는 순서를 바꾸면 카메라의 양의 z축을 가리키는 벡터를 얻을 수 있습니다.

```c++
glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
```

!!! note "왜 빼야하죠?"
    벡터 $\vec{a}$와 $\vec{b}$가 있다고 가정해 봅시다. ($\vec{a}$는 카메라의 위치이고, $\vec{b}$는 카메라가 보고 있는 목표점입니다.) 이때 $\vec{a}$와 $\vec{b}$ 사이의 방향을 구하고 싶다면 둘을 빼면 됩니다.

    \[
    \vec{ab} = \vec{b} - \vec{a}
    \]

    만약 $(0,0,0)$을 바라보는 카메라의 위치 $(0,0,3)$이 있다고 가정합시다. 이 때 위 공식을 사용해본다면

    \[
    (0,0,0) - (0,0,3) = (0,0,-3)
    \]

    이므로 방향은 $(0,0,-3)$이 됩니다. 또한 이 방향을 단위벡터로 만든다면 완전히 방향만을 나타내게 됩니다. 위 코드블록에서 `glm::normalize`를 사용해 그렇게 만들었습니다. 아직 이해가 되지 않았다면 다른 예시도 상상해 보세요.

!!! warning ""
    참고로 '방향 벡터'라는 이름은 그다지 적절하지 않습니다. 왜냐하면 실제로는 목표로 하는 것과 정반대 방향을 가리키기 때문입니다.


### 3. 우측 축

다음으로 필요한 벡터는 카메라 공간의 양의 x축을 나타내는 오른쪽 벡터입니다. 오른쪽 벡터를 얻기 위해 약간의 트릭을 사용하는데, 먼저 위쪽 방향(월드 공간 기준)을 가리키는 상향 벡터를 지정합니다. 그런 다음 이 상향 벡터와 2단계에서 구한 방향 벡터의 외적을 수행합니다. 외적의 결과는 두 벡터 모두에 수직인 벡터이므로 양의 x축 방향을 가리키는 벡터를 얻게 됩니다(외적 순서를 바꾸면 음의 x축 방향을 가리키는 벡터를 얻게 됩니다).

```c++
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
```

!!! note "glm::cross"
    `glm::cross` 함수는 두 벡터의 외적을 수행하는 함수입니다.

### 4. 위쪽 축

이제 x축 벡터와 z축 벡터를 모두 얻었으므로 카메라의 양의 y축을 가리키는 벡터를 찾는 것은 비교적 쉽습니다. 오른쪽 벡터와 방향 벡터의 외적을 취하면 됩니다.

```c++
glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
```

외적과 몇 가지 트릭을 활용하여 뷰/카메라 공간을 구성하는 모든 벡터를 생성할 수 있었습니다. 수학에 좀 더 익숙한 독자분들을 위해 설명드리자면, 이 과정은 선형대수학에서 [그람-슈미트](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process) 과정으로 알려져 있습니다. 이러한 카메라 벡터를 사용하여 카메라를 생성하는 데 매우 유용한 **LookAt**{:.g} 행렬을 만들 수 있습니다.

## Look At

행렬의 가장 큰 장점은 서로 수직인 3개의 축(또는 비선형 축)을 사용하여 좌표 공간을 정의하면, 이 3개의 축과 변환 벡터를 포함하는 행렬을 만들 수 있고, 이 행렬을 곱하여 어떤 벡터든 해당 좌표 공간으로 변환할 수 있다는 것입니다. LookAt 행렬이 바로 이러한 원리를 이용하며, 이제 카메라 공간을 정의하는 3개의 수직 축과 위치 벡터를 사용하여 LookAt 행렬을 직접 만들어 보겠습니다.

\[
LookAt = \begin{bmatrix} \textcolor{red}{R_x} & \textcolor{red}{R_y} & \textcolor{red}{R_z} & 0 \\ \textcolor{green}{U_x} & \textcolor{green}{U_y} & \textcolor{green}{U_z} & 0 \\ \textcolor{blue}{D_x} & \textcolor{blue}{D_y} & \textcolor{blue}{D_z} & 0 \\ 0 & 0 & 0  & 1 \end{bmatrix} * \begin{bmatrix} 1 & 0 & 0 & -\textcolor{purple}{P_x} \\ 0 & 1 & 0 & -\textcolor{purple}{P_y} \\ 0 & 0 & 1 & -\textcolor{purple}{P_z} \\ 0 & 0 & 0  & 1 \end{bmatrix}
\]

여기서 $\textcolor{red}{R}$은 오른쪽 벡터, $\textcolor{green}{U}$는 위쪽 벡터, $\textcolor{blue}{D}$는 방향 벡터, $\textcolor{purple}{P}$는 카메라의 위치 벡터입니다. 회전(왼쪽 행렬)과 이동(오른쪽 행렬) 부분은 반전(각각 전치 및 부호 반전)되는데, 이는 카메라 이동 방향의 반대 방향으로 월드 좌표계를 회전시키고 이동시키기 위함입니다. 이 LookAt 행렬을 뷰 행렬로 사용하면 모든 월드 좌표계가 방금 정의한 뷰 공간으로 변환됩니다. LookAt 행렬은 이름 그대로 주어진 대상을 바라보는 뷰 행렬을 생성합니다.

다행히 GLM은 이 모든 작업을 이미 수행해 줍니다. 우리는 카메라 위치, 목표 위치, 그리고 월드 공간에서의 업 벡터(오른쪽 벡터를 계산하는 데 사용했던 업 벡터)를 나타내는 벡터만 지정하면 됩니다. 그러면 GLM이 뷰 행렬로 사용할 수 있는 LookAt 행렬을 생성합니다.

```c++
glm::mat4 view;
view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), 
  		   glm::vec3(0.0f, 0.0f, 0.0f), 
  		   glm::vec3(0.0f, 1.0f, 0.0f));
```

`glm::lookAt` 함수는 위치, 대상 및 상향 벡터를 각각 필요로 합니다. 이 예제는 이전 장에서 생성한 것과 동일한 뷰 행렬을 생성합니다.

사용자 입력을 처리하기 전에, 먼저 카메라를 장면 주위로 회전시켜 보겠습니다. 장면의 기준점은 (0,0,0)으로 유지합니다. 삼각법을 이용하여 매 프레임마다 원 위의 한 점을 나타내는 x, z 좌표를 생성하고, 이 좌표를 카메라 위치로 사용합니다. x, y 좌표를 시간에 따라 다시 계산함으로써 원 위의 모든 점을 순회하게 되고, 따라서 카메라가 장면을 중심으로 회전하게 됩니다. 이 원을 미리 정의된 반지름만큼 확장하고, GLFW의 `glfwGetTime` 함수를 사용하여 매 프레임마다 새로운 뷰 행렬을 생성합니다.

```c++
const float radius = 10.0f;
float camX = sin(glfwGetTime()) * radius;
float camZ = cos(glfwGetTime()) * radius;
glm::mat4 view;
view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0)); 
```

이 코드를 실행하면 다음과 같은 결과가 나올 것입니다. (클릭해서 확인하세요.)

<figure class="video_container">
  <video loop onclick="this.paused ? this.play() : this.pause();">
    <source src="/static/camera_circle.mp4" type="video/webm">
  </video>
</figure>

이 간단한 코드 조각을 사용하면 카메라가 시간이 지남에 따라 장면 주위를 회전합니다. 반지름과 위치/방향 매개변수를 변경하면서 LookAt 행렬이 어떻게 작동하는지 직접 경험해 보세요. 또한, 막히는 부분이 있으면 [소스 코드](https://github.com/JoeyDeVries/LearnOpenGL/blob/master/src/1.getting_started/7.1.camera_circle/camera_circle.cpp)를 참고하세요.

## 걸어 보기

> 나는 걷는 방법을 알지 못해 - 컴퓨터

장면에서 카메라를 이리저리 움직이는 것도 재미있지만, 모든 움직임을 직접 구현하는 것이 훨씬 더 재미있습니다! 먼저 카메라 시스템을 설정해야 하므로 프로그램 상단에서 몇 가지 카메라 변수를 정의하는 것이 유용합니다.

```c++
glm::vec3 cameraPos   = glm::vec3(0.0f, 0.0f,  3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp    = glm::vec3(0.0f, 1.0f,  0.0f);
```

LookAt 함수는 이제 다음과 같이 됩니다.

```c++
view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
```

먼저 카메라 위치를 이전에 정의한 cameraPos로 설정합니다. 방향은 현재 위치에 방금 정의한 방향 벡터를 더한 값입니다. 이렇게 하면 카메라가 어떻게 움직이든 항상 목표 방향을 바라보게 됩니다. 이제 키를 누를 때 cameraPos 벡터를 업데이트하여 이러한 변수들을 좀 더 다양하게 활용해 보겠습니다.

GLFW의 키보드 입력을 관리하는 processInput 함수를 이미 정의했으므로 몇 가지 추가 키 명령을 추가해 보겠습니다.

```c++
void processInput(GLFWwindow *window)
{
    ...
    const float cameraSpeed = 0.05f; // 적절히 변경하세요
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        cameraPos += cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        cameraPos -= cameraSpeed * cameraFront;
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
}
```

WASD 키를 누를 때마다 카메라 위치가 그에 따라 업데이트됩니다. 앞뒤로 이동하려면 위치 벡터에 속도 값을 곱한 값을 더하거나 빼면 됩니다. 좌우로 이동하려면 외적을 계산하여 우측 벡터를 만들고, 이 우측 벡터를 따라 이동합니다. 이렇게 하면 카메라를 사용할 때 익숙한 좌우 이동 효과가 나타납니다.

!!! tip ""
    참고로, 우리는 결과로 나오는 오른쪽 벡터를 정규화합니다. 만약 이 벡터를 정규화하지 않으면, 카메라 전면(cameraFront) 변수에 따라 외적의 벡터 크기가 달라질 수 있습니다. 벡터를 정규화하지 않으면 카메라 방향에 따라 움직임이 느려지거나 빨라져서 일정한 속도로 움직이지 못하게 됩니다.

이제 카메라를 어느 정도 움직일 수 있을 것입니다. 다만, 움직임 속도는 시스템에 따라 다르므로 cameraSpeed ​​값을 조정해야 할 수도 있습니다.[^1]

[^1]: 우리는 아직 델타타임(FPS와 상관없이 값을 변환할 수 있게 해주는 기술) 또는 그와 유사한 기술을 사용하지 않기 때문에, 시스템 FPS에 따라 이동 속도에 차이가 생깁니다.

