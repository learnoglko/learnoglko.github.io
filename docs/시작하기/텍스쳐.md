# 텍스쳐
우리는 객체에 더 많은 디테일을 추가하기 위해 각 정점에 색상을 지정하여 흥미로운 이미지를 만들 수 있다는 것을 알게 되었습니다. 하지만 상당한 사실감을 얻으려면 많은 정점이 필요하고 그만큼 많은 색상을 지정해야 합니다. 이는 각 모델에 더 많은 정점이 필요하고 각 정점에 색상 속성이 있어야 하므로 상당한 추가 오버헤드를 발생시킵니다.

일반적으로 아티스트와 프로그래머들이 선호하는 방식은 **텍스처**{:.g}를 사용하는 것입니다. 텍스처는 객체에 디테일을 더하기 위해 사용되는 2D 이미지입니다(1D 및 3D 텍스처도 존재합니다). 예를 들어, 멋진 벽돌 이미지가 그려진 종이를 3D 집 위에 깔끔하게 접어 붙여 집 외벽이 돌로 된 것처럼 보이게 하는 것을 텍스처라고 생각해 보세요. 하나의 이미지에 많은 디테일을 담을 수 있기 때문에, 추가적인 정점을 지정하지 않고도 객체가 매우 정교해 보이는 효과를 줄 수 있습니다.

!!! tip ""
    이미지 외에도 텍스처는 셰이더로 전송할 다양한 종류의 데이터를 저장하는 데 사용할 수 있지만, 이는 다른 주제에서 다루도록 하겠습니다.

아래 이미지는 이전 장에서 다룬 삼각형에 ![벽돌 벽의 텍스처](https://learnopengl.com/img/textures/wall.jpg)를 적용한 것입니다.

![](../static/textures.png)

삼각형에 텍스처를 매핑하려면 삼각형의 각 정점에 텍스처의 어느 부분에 해당하는지 알려줘야 합니다. 따라서 각 정점에는 텍스처 이미지의 어느 부분을 샘플링할지 지정하는 **텍스처 좌표(texture coordinate)**{:.g}가 연결되어야 합니다. 그런 다음 프래그먼트 보간이 나머지 프래그먼트에 대해 작업을 수행합니다.

텍스처 좌표는 x축과 y축에서 0부터 1까지의 범위를 갖습니다(2D 텍스처 이미지를 사용한다는 점을 기억하세요). 텍스처 좌표를 사용하여 텍스처 색상을 추출하는 것을 **샘플링(sampling)**{:.g}이라고 합니다. 텍스처 좌표는 텍스처 이미지의 왼쪽 아래 모서리를 (0,0)에서 시작하여 오른쪽 위 모서리를 (1,1)에서 시작합니다. 다음 이미지는 텍스처 좌표를 삼각형에 매핑하는 방법을 보여줍니다.

![](../static/tex_coords.png)

삼각형에 대해 3개의 텍스처 좌표점을 지정합니다. 삼각형의 왼쪽 아래 변이 텍스처의 왼쪽 아래 변과 일치하도록 (0,0)을 왼쪽 아래 꼭짓점으로 사용합니다. 오른쪽 아래 변도 마찬가지로 (1,0)을 텍스처 좌표로 사용합니다. 삼각형의 윗면은 텍스처 이미지의 중앙 상단에 해당해야 하므로 (0.5,1.0)을 텍스처 좌표로 사용합니다. 정점 셰이더에는 3개의 텍스처 좌표만 전달하면 되며, 정점 셰이더는 이 좌표들을 프래그먼트 셰이더로 전달하여 각 프래그먼트에 대해 모든 텍스처 좌표를 깔끔하게 보간합니다.

그러면 결과적인 텍스처 좌표는 다음과 같습니다.

```c++
float texCoords[] = {
    0.0f, 0.0f,  // lower-left corner  
    1.0f, 0.0f,  // lower-right corner
    0.5f, 1.0f   // top-center corner
};
```

텍스처 샘플링은 해석이 자유롭고 다양한 방식으로 구현될 수 있습니다. 따라서 우리는 OpenGL에게 텍스처를 어떻게 샘플링해야 하는지 알려주는 것이 우리의 역할입니다.